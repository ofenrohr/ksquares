/***************************************************************************
 *   Copyright (C) 2015 by Tom Vincent Peters   <kde@vincent-peters.de>    *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 ***************************************************************************/

#include "qdab.h"

#include <QString>
#include <QDataStream>
#include <QByteArray>
#include <QDateTime>
#include <QCoreApplication>

#include <qjson/parser.h>

// generated
#include "externalaipath.h"

QDab::QDab(int newPlayerId, int /*newMaxPlayerId*/, int newWidth, int newHeight, int /*newLevel*/, int thinkTime) : KSquaresAi(newWidth, newHeight)
{
	timeout = thinkTime;
	playerId = newPlayerId;
	isTainted = false;
	qdabServerListening = false;
	qdabStdOutStream.setString(&qdabStdOut);
	qdabStdErrStream.setString(&qdabStdErr);
	
	// start qdab server
	QString qdabWorkingDirectory = QString(EXTERNALAIPATH) + "/qdab";
	QString qdabServerExecutable = QString(EXTERNALAIPATH) + "/qdab/server";
	QStringList qdabServerArguments;
	QProcessEnvironment qdabEnvironment = QProcessEnvironment::systemEnvironment();
	QString libPath = "";
	if (qdabEnvironment.contains("LD_LIBRARY_PATH"))
		libPath = qdabEnvironment.value("LD_LIBRARY_PATH") + ":";
	libPath.append(qdabWorkingDirectory);
	qdabEnvironment.insert("LD_LIBRARY_PATH", libPath);
	
	qdabServer = new QProcess();
	qRegisterMetaType<QProcess::ProcessError>("QProcess::ProcessError");
	qRegisterMetaType<QProcess::ProcessState>("QProcess::ProcessState");
	qRegisterMetaType<QProcess::ExitStatus>("QProcess::ExitStatus");
	connect(qdabServer, SIGNAL(error(QProcess::ProcessError)), this, SLOT(processError(QProcess::ProcessError)));
	connect(qdabServer, SIGNAL(stateChanged(QProcess::ProcessState)), this, SLOT(processStateChanged(QProcess::ProcessState)));
	connect(qdabServer, SIGNAL(finished(int, QProcess::ExitStatus)), this, SLOT(processFinished(int, QProcess::ExitStatus)));
	connect(qdabServer, SIGNAL(readyReadStandardError()), this, SLOT(processReadyReadStandardError()));
	connect(qdabServer, SIGNAL(readyReadStandardOutput()), this, SLOT(processReadyReadStandardOutput()));
	
	kDebug() << "starting qdabServer: " << qdabServerExecutable << ", ARGS: " << qdabServerArguments;
	qdabServer->setWorkingDirectory(qdabWorkingDirectory);
	qdabServer->setProcessEnvironment(qdabEnvironment);
	qdabServer->start(qdabServerExecutable, qdabServerArguments);
	qdabServer->setReadChannel(QProcess::StandardError);
	
	QCoreApplication::processEvents();
	if (!qdabServer->waitForStarted())
	{
		kDebug() << "ERROR: starting qdabServer failed!";
	}
	if (!qdabServer->waitForReadyRead())
	{
		kDebug() << "Waiting for ready read failed";
	}
	
	if (newWidth != 5 || newHeight != 5)
	{
		kDebug() << "ERROR: qdab only supports 5x5 boards!";
		isTainted = true;
	}
	
	lastTurnTime = -1;
}

QDab::~QDab()
{
	if (qdabServer!=NULL)
	{
		disconnect(qdabServer, SIGNAL(error(QProcess::ProcessError)), this, SLOT(processError(QProcess::ProcessError)));
		disconnect(qdabServer, SIGNAL(stateChanged(QProcess::ProcessState)), this, SLOT(processStateChanged(QProcess::ProcessState)));
		disconnect(qdabServer, SIGNAL(finished(int, QProcess::ExitStatus)), this, SLOT(processFinished(int, QProcess::ExitStatus)));
		disconnect(qdabServer, SIGNAL(readyReadStandardError()), this, SLOT(processReadyReadStandardError()));
		disconnect(qdabServer, SIGNAL(readyReadStandardOutput()), this, SLOT(processReadyReadStandardOutput()));
		if (qdabServer->state() != QProcess::NotRunning)
		{
			kDebug() << "trying to kill qdabServer process";
			qdabServer->kill();
			qdabServer->terminate();
			if (qdabServer->waitForFinished())
				kDebug() << "killed qdabServer";
			else
				kDebug() << "killing qdabServer failed!";
		}
		delete qdabServer;
	}
}


int QDab::randomMove(const QList<bool> &lines)
{
	kDebug() << "WARNING: returning random move that was not generated by qdab";
	isTainted = true;
	QList<int> freeLines;
	for (int i = 0; i < lines.size(); i++)
	{
		if (!lines[i])
			freeLines.append(i);
	}
	lastTurnTime = -1;
	return freeLines.at(qrand() % freeLines.size());
}

// def num2move(self, value, who, step=-1):
//         ty, x, y = 1, -1, -1
//         if (value&(1<<31)) != 0:
//             ty = 0 # horizon
//         for i in range(5)[::step]:
//             for j in range(6)[::step]:
//                 if (value&1) == 1:
//                     if ty == 0: x, y = j, i
//                     else: x, y = i, j
//                     break
//                 value >>= 1
//             if x != -1:
//                 break
//         return (ty, x, y, who)




int QDab::getMoveFromQueue(const QList<bool> linesList)
{
	kDebug() << "Current move queue: " << moveQueue;
	if (moveQueue.size() <= 0)
	{
		kDebug() << "ERROR: move queue is empty!";
		return -1;
	}
	for (int i = 0; i < moveQueue.size(); i++)
	{
		int line = moveQueue[i];
		QList<int> adjacentSquares = squaresFromLine(line);
		for (int j = 0; j < adjacentSquares.size(); j++)
		{
			int adjacentSquareLines[4];
			linesFromSquare(adjacentSquareLines, adjacentSquares[j]);
			int cnt = 0;
			for (int k = 0; k < 4; k++)
			{
				if (linesList[adjacentSquareLines[k]])
					cnt++;
			}
			if (cnt == 3)
			{
				kDebug() << "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";
				kDebug() << "returning move from queue: " << line;
				kDebug() << "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~";
				
				moveQueue.removeAt(i);
				return line;
			}
		}
	}
	kDebug() << "returning last move from queue";
	return moveQueue.takeLast();
}


int QDab::chooseLine(const QList<bool> &newLines, const QList<int> &/*newSquareOwners*/, const QList<Board::Move> &lineHistory)
{
	QCoreApplication::processEvents();
	if (!qdabServer->state() == QProcess::Running)
	{
		kDebug() << "WARNING: qdab server not running";
		qdabServer->waitForStarted();
		kDebug() << "wait for started returned, trying to get move";
	}
	if (!qdabServerListening)
	{
		kDebug() << "WARNING: qdab server might not be listening...";
		qdabServer->waitForReadyRead();
	}
	
	if (moveQueue.size() > 0)
	{
		return getMoveFromQueue(newLines);
	}
	
	uint h = 0;
	uint v = 0;
	// send all moves from history
	for (int i = 0; i < newLines.size(); i++)
	{
		if (!newLines[i])
			continue;
		QPoint p1, p2;
		// qdab origin is at bottom right
		// ksquares origin is at top left
		Board::indexToPoints(i, &p1, &p2, 5, 5, false);
		//kDebug() << "dir,x,y: ("<< (p1.x() != p2.x() ? 0 : 1) <<", " << p1.x() << "," << p1.y() << ")";
		if (p1.x() != p2.x())
			v |= (1<<(p1.x()*6+p1.y()));
		else
			h |= (1<<(p1.y()*6+p1.x()));
	}
	
	// only send the newest move sequence
// 	int lastPlayer = -1;
// 	for (int i = lineHistory.size()-1; i >= 0; i--)
// 	{
// 		if (lastPlayer == -1)
// 		{
// 			lastPlayer = lineHistory[i].player;
// 		}
// 		if (lineHistory[i].player != lastPlayer)
// 			break;
// 		QPoint p1, p2;
// 		Board::indexToPoints(lineHistory[i].line, &p1, &p2, 5, 5, false);
// 		//kDebug() << "dir,x,y: ("<< (p1.x() != p2.x() ? 0 : 1) <<", " << p1.x() << "," << p1.y() << ")";
// 		if (p1.x() != p2.x())
// 			v |= (1<<(p1.x()*6+p1.y()));
// 		else
// 			h |= (1<<(p1.y()*6+p1.x()));
// 	}
	
	int turn = 1;
	int tmpPlr = 0;
	for (int i = 0; i < lineHistory.size(); i++)
	{
		if (tmpPlr != lineHistory[i].player)
		{
			tmpPlr = lineHistory[i].player;
			turn++;
		}
	}
	
	// send stuff to qdab server
	const int connectionTimeout = 1000;

	QTcpSocket socket;
	socket.connectToHost("0.0.0.0", 12345);

	if (!socket.waitForConnected(connectionTimeout))
	{
		kDebug() << "error (wait for connected): " << socket.errorString();
		return randomMove(newLines);
	}
	
	uint id = QDateTime::currentDateTime().toTime_t();
	
	QString request = "{\"params\": [{\"Timeout\": "+QString::number(timeout)+", \"Board\": {\"H\": "+QString::number(h)+", \"S\": [0, 0], \"Now\": "+QString::number(playerId)+", \"Turn\": "+QString::number(turn)+", \"V\": "+QString::number(v)+"}, \"Algorithm\": \"quctann\"}], \"id\": "+QString::number(id)+", \"method\": \"Server.MakeMove\"}";
	QByteArray sendBA = request.toAscii();
	socket.write(sendBA);
	kDebug() << "request: " << sendBA;
	socket.waitForBytesWritten();
	
	QElapsedTimer turnTimer;
	turnTimer.start();
	
	// get response from qdab server
	QByteArray responseBA;
	bool done = false;
	while (!done)
	{
		if (socket.state() != QAbstractSocket::ConnectedState)
		{
			kDebug() << "state: " << socket.state();
			break;
		}
		socket.waitForReadyRead(100);
		//kDebug() << ".";
		if (socket.bytesAvailable() > 0)
		{
			responseBA.append(socket.readAll());
		}
		done = responseBA.count('{') > 0 && responseBA.count('{') == responseBA.count('}');
	}
	
	kDebug() << "response: " << responseBA;
	
	lastTurnTime = turnTimer.elapsed();
	
	// parse response from qdab server
	QJson::Parser jsonParser;
	bool parseOk;
	QVariantMap result = jsonParser.parse(responseBA, &parseOk).toMap();
	
	if (!parseOk)
	{
		kDebug() << "parsing failed! json error: " << jsonParser.errorString();
		return randomMove(newLines);
	}
	
	kDebug() << "parsed json: " << result;
	if (result["id"] != id)
	{
		kDebug() << "ids dont match, aborting. original id = " << id << ", recv id = " << result["id"];
		return randomMove(newLines);
	}
	if (!result["error"].isNull())
	{
		kDebug() << "qdab error: " << result["error"];
		return randomMove(newLines);
	}
	QVariantMap resultHV = result["result"].toMap();
	unsigned long long rh = resultHV["H"].toULongLong();
	unsigned long long rv = resultHV["V"].toULongLong();
	kDebug() << "result hv: " << rh << ", " << rv;
	
	for (int i = 0; i < 30; i++)
	{
		if ( (1<<i) & rh )
		{
			QPoint pa((i % 6), (i / 6));
			QPoint pb(pa.x(), pa.y() + 1);
			int idx = Board::pointsToIndex(pa, pb, 5, 5);
			kDebug() << "H: i: " << i << ", idx: " << idx << ", pa: " << pa << ", pb: " << pb;
			if (idx >= newLines.size() || idx < 0)
			{
				kDebug() << "error: invalid index from points! idx: " << idx << ", pa: " << pa << ", pb: " << pb;
				//continue;
			}
			else
			{
				if (!newLines[idx])
					moveQueue.append(idx);
				else
					kDebug() << "old line: " << idx << ", pa: " << pa << ", pb: " << pb;
			}
		}
		
		if ( (1<<i) & rv )
		{
			QPoint pa((i/ 6), (i % 6));
			QPoint pb(pa.x() + 1, pa.y());
			int idx = Board::pointsToIndex(pa, pb, 5, 5);
			kDebug() << "V: i: " << i << ", idx: " << idx << ", pa: " << pa << ", pb: " << pb;
			if (idx >= newLines.size() || idx < 0)
			{
				kDebug() << "error: invalid index from points! idx: " << idx << ", pa: " << pa << ", pb: " << pb;
				//continue;
			}
			else
			{
				if (!newLines[idx])
					moveQueue.append(idx);
				else
					kDebug() << "old line: " << idx << ", pa: " << pa << ", pb: " << pb;
			}
		}
	}

	return getMoveFromQueue(newLines);
}

void QDab::processError(const QProcess::ProcessError &error)
{
	kDebug() << "Got error signal from qdab!";
	QString info = "";
	switch (error)
	{
		case QProcess::FailedToStart: info = "The process failed to start. Either the invoked program is missing, or you may have insufficient permissions to invoke the program."; break;
		case QProcess::Crashed: info = "The process crashed some time after starting successfully."; break;
		case QProcess::Timedout: info = "The last waitFor...() function timed out. The state of QProcess is unchanged, and you can try calling waitFor...() again."; break;
		case QProcess::WriteError: info = "An error occurred when attempting to write to the process. For example, the process may not be running, or it may have closed its input channel."; break;
		case QProcess::ReadError: info = "An error occurred when attempting to read from the process. For example, the process may not be running."; break;
		case QProcess::UnknownError: info = "An unknown error occurred. This is the default return value of error()."; break;
	}
	kDebug() << "****************************************************************";
	kDebug() << "***                        QDAB ERROR                        ***";
	kDebug() << "****************************************************************";
	kDebug() << "qdab error: " << info;
}

void QDab::processStateChanged(const QProcess::ProcessState &newState)
{
	kDebug() << "processStateChanged!";
	kDebug() << "****************************************************************";
	kDebug() << "***                    QDAB STATE CHANGED                    ***";
	kDebug() << "****************************************************************";
	QString state = "";
	switch (newState)
	{
		case QProcess::NotRunning: state = "NotRunning"; break;
		case QProcess::Starting: state = "Starting"; break;
		case QProcess::Running: state = "Running"; break;
	}
	kDebug() << "qdab state: " << state;
}

void QDab::processFinished(const int &exitCode, const QProcess::ExitStatus &exitStatus)
{
	kDebug() << "processFinished!";
	kDebug() << "qdab exit code: " << exitCode;
	kDebug() << "qdab exit status: " << (exitStatus == QProcess::NormalExit ? "normal" : "crash");
}

void QDab::processReadyReadStandardError()
{
	kDebug() << "processReadyReadStandardError!";
	qdabServer->setReadChannel(QProcess::StandardError);
	QByteArray qdabStdErrTmp = qdabServer->readAll();
	kDebug() << qdabStdErrTmp;
	qdabStdErrStream << qdabStdErrTmp;
	qdabStdErrStream.flush();
	//kDebug() << "qdab stderr: " << QString(qdabStdErrTmp);
	if (qdabStdErr.contains("Server runing on"))
	{
		kDebug() << "qdab server is listening";
		qdabServerListening = true;
	}
}

void QDab::processReadyReadStandardOutput()
{
	kDebug() << "processReadyReadStandardOutput!";
	qdabServer->setReadChannel(QProcess::StandardOutput);
	QByteArray qdabStdOutTmp = qdabServer->readAll();
	qdabStdOutStream << qdabStdOutTmp;
	qdabStdOutStream.flush();
	//kDebug() << "qdab stdout: " << QString(qdabStdOutTmp);
}

#include "qdab.moc"